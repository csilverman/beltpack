
/*	UTILITIES
	=========
	
	These provide useful functions for writing your own mixins. They're also used by mixins in Beltpack itself, so they should come first.
*/
	
/*
	As far as I can tell, there doesn't seem to be a function to get a key-value pair from a map based on index number. This might be clumsy, but it works: iterate across the map, incrementing a counter, until the counter matches the specified index, at which point you return the value.

*/
@function get-map-value-by-index($map, $index) {
  $i: 0;
  @each $key, $value in $map {
    $i: $i + 1;
    @if $i == $index {
      @return $value;
    }
  }
}


// =============================================================================
// String Replace - https://gist.github.com/jonathantneal/d0460e5c2d5d7f9bc5e6
// =============================================================================

@function str-replace($string, $search, $replace: "") {
	$index: str-index($string, $search);

	@if $index {
		@return str-slice($string, 1, $index - 1) + $replace + str-replace(str-slice($string, $index + str-length($search)), $search, $replace);
	}

	@return $string;
}

@mixin break($break, $min-or-max:'min') {
	/*	Sets up a media query. This expects that all of a project's breakpoints will
	    be stored in a map named $breakpoints, as follows:

$breakpoints: (
	"small": 30em,
	"medium": 50em,
	"large": 70em
);	
	*/
	$screen-size: map-get($breakpoints, $break);
	@media screen and (#{$min-or-max}-width: $screen-size) {
		@content
	}
}

//	The first value is always the base one, the one outside the media queries. This is what would typically be applied at the smallest screen size.
//	Issue: set it so it can handle if someone adds a fourth breakpoint parameter but there are only three breakpoints

@mixin prop($property, $values...) {
  $i: 0;
  @each $value in $values {
    @if $i == 0 {
      #{$property}: $value;
    }
    @else {
      @media screen and (min-width: get-map-value-by-index($breakpoints, $i)) {
        #{$property}: $value;
      }
    }
    $i: $i+1;
  }
}



/*	The following are by Hugo Giraudel
*/

@function reverse($list, $recursive: false) {
  $result: ();

  @for $i from length($list) * -1 through -1 {
    @if type-of(nth($list, abs($i))) == list and $recursive {
      $result: append($result, reverse(nth($list, abs($i)), $recursive));
    } @else {
      $result: append($result, nth($list, abs($i)));
    }
  }

  @return $result;
}














